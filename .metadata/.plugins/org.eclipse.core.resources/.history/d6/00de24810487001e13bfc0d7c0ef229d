package gameplay;

import entity.Entity;
import entity.Weapon;

public class CollisionChecker {
	GamePanel gameP;
	public CollisionChecker(GamePanel gp) {
		gameP = gp;
	}
	
	public void checkTile(Entity ent) {	//It is lehetne intersectel megvizsgálni, de az túl "drága" így csak 2 tilet vizsgálunk, nem 20x15-öt
		int entLeftX = ent.getX() + ent.hitbox.x;
		int entRightX = ent.getX() + ent.hitbox.x + ent.hitbox.width;
		int entTopY = ent.getY() + ent.hitbox.y;
		int entBottomY = ent.getY() + ent.hitbox.y + ent.hitbox.height;
		
		int entLeftCol = entLeftX/gameP.tileSize;
		int entRightCol = entRightX/gameP.tileSize;
		int entTopRow = entTopY/gameP.tileSize;
		int entBottomRow = entBottomY/gameP.tileSize;
		
		int tileNum1, tileNum2;
		
		switch(ent.move_dir) {
		case "up":
			entTopRow = (entTopY - ent.getSpeed())/gameP.tileSize;	//Megnézzük, merre lesz a player
			tileNum1 = gameP.tileMg.map[entLeftCol][entTopRow];
			tileNum2 = gameP.tileMg.map[entRightCol][entTopRow];
			if(gameP.tileMg.tiles[tileNum1].isSolid() || gameP.tileMg.tiles[tileNum2].isSolid()) {
				ent.collisionOn = true;
			}
			break;
		case "down":
			entBottomRow = (entBottomY + ent.getSpeed())/gameP.tileSize;	//Megnézzük, merre lesz a player
			if(entBottomRow >= gameP.maxSor) {	// Mivel ha az ajján vagyunk, akkor a kisebbített hitbox következő poziciója már a képen kivül lenne, ami pedig túlidexelést jelentene, egyből azt állítjuk nem tud menni tovább
				ent.collisionOn = true;
				break;
			}
			tileNum1 = gameP.tileMg.map[entLeftCol][entBottomRow];
			tileNum2 = gameP.tileMg.map[entRightCol][entBottomRow];
			if(gameP.tileMg.tiles[tileNum1].isSolid() || gameP.tileMg.tiles[tileNum2].isSolid()) {
				ent.collisionOn = true;
			}
			break;
		case "left":
			entLeftCol = (entLeftX - ent.getSpeed())/gameP.tileSize;	//Megnézzük, merre lesz a player
			tileNum1 = gameP.tileMg.map[entLeftCol][entTopRow];
			tileNum2 = gameP.tileMg.map[entLeftCol][entBottomRow];
			if(gameP.tileMg.tiles[tileNum1].isSolid() || gameP.tileMg.tiles[tileNum2].isSolid()) {
				ent.collisionOn = true;
			}
			break;
		case "right":
			entRightCol = (entRightX + ent.getSpeed())/gameP.tileSize;	//Megnézzük, merre lesz a player
			tileNum1 = gameP.tileMg.map[entRightCol][entTopRow];
			tileNum2 = gameP.tileMg.map[entRightCol][entBottomRow];
			if(gameP.tileMg.tiles[tileNum1].isSolid() || gameP.tileMg.tiles[tileNum2].isSolid()) {
				ent.collisionOn = true;
			}
			break;
		}
	}
	public int checkObject(Entity ent, boolean player) {
		int index = 999;
		
		for(int i = 0; i < gameP.objects.size(); i++) {
			if(gameP.objects.get(i) != null) {
				// Entity hitbox poziciója kiszámítása
				ent.hitbox.x = ent.getX() + ent.hitbox.x;
				ent.hitbox.y = ent.getY() + ent.hitbox.y;
				// Object hitbox poziciója kiszámítása
				gameP.objects.get(i).hitbox.x += gameP.objects.get(i).x;
				gameP.objects.get(i).hitbox.y += gameP.objects.get(i).y;
				
				switch(ent.move_dir) {
				case "up":
					ent.hitbox.y -= ent.getSpeed();
					if(ent.hitbox.intersects(gameP.objects.get(i).hitbox)) {	//Ha összeérnek akkor igazat ad vissza
						if(gameP.objects.get(i).collision == true) {
							ent.collisionOn = true;
						}
						if(player == true) {
							index = i;	// Ha a playerért hozzá akkor visszaadjuk annak az indexét, de ha nem akkor 999-et adunk vissza, anniy objectünk biztos nem lesz egyszerre a képen
						}
					}
					break;
				case "down":
					ent.hitbox.y += ent.getSpeed();
					if(ent.hitbox.intersects(gameP.objects.get(i).hitbox)) {	//Ha összeérnek akkor igazat ad vissza
						if(gameP.objects.get(i).collision == true) {
							ent.collisionOn = true;
						}
						if(player == true) {
							index = i;
						}
					}
					break;
				case "left":
					ent.hitbox.x -= ent.getSpeed();
					if(ent.hitbox.intersects(gameP.objects.get(i).hitbox)) {	//Ha összeérnek akkor igazat ad vissza
						if(gameP.objects.get(i).collision == true) {
							ent.collisionOn = true;
						}
						if(player == true) {
							index = i;
						}
					}
					break;
				case "right":
					ent.hitbox.x += ent.getSpeed();
					if(ent.hitbox.intersects(gameP.objects.get(i).hitbox)) {	//Ha összeérnek akkor igazat ad vissza
						if(gameP.objects.get(i).collision == true) {
							ent.collisionOn = true;
						}
						if(player == true) {
							index = i;
						}
					}
					break;
				}
				ent.resetHitboxToDefault();
				gameP.objects.get(i).resetHitboxToDefault();
			}
		}
		return index;
	}
	
	public void checkWeaponDestroys(Entity player, Weapon wep) {
		if(wep.isAttacking()) {
			//Weapon hitbox position kiszámítása
			wep.getAttackHitbox().hitbox.x += player.getX();
			wep.getAttackHitbox().hitbox.y += player.getY();
			System.out.println("x: " + wep.getAttackHitbox().hitbox.x + "y: " + wep.getAttackHitbox().hitbox.y);
			for(int i = 0; i < gameP.objects.size(); i++) {
				if(gameP.objects.get(i) != null && wep.isAttacking()) {
					//Object hitbox position kiszámítása
					gameP.objects.get(i).hitbox.x += gameP.objects.get(i).x;
					gameP.objects.get(i).hitbox.y += gameP.objects.get(i).y;
					
					if(wep.getAttackHitbox().hitbox.intersects(gameP.objects.get(i).hitbox)) {
						gameP.objects.get(i).destroy();
					}
					gameP.objects.get(i).resetHitboxToDefault();
				}
			}
			wep.getAttackHitbox().resetHitboxToDefault();
		}
	}
}
